# ncurse的颜色机制.
`printw`等输出函数不会立马将字符显示, 而是带着颜色属性`color_pair`, 也就是一个数字编号, 放在缓冲区里, 由`refresh()`将其一次性输出. 而输出时的颜色绑定, 是由最后一次`init_color(color_pair, A,B)`决定的.   

默认的颜色, 无论前景还是背景, 都是以256为周期循环. 先是几个纯色, 然后是一些主色带领的渐变色. 而可以组合出的颜色数量, 当然是`65536`, 但是默认的color_pair最多只能同时存在256种.

我进行了一系列测试, 当然它可以支持很多颜色, 但对于我希望的"现代终端显示能力的极限"来说, 这是非常混乱和糟糕的接口设计. ncurses或许更倾向于跨平台和稳定, 但游戏追求多姿多彩.


我有点想用自带的颜色输出了. 它所有的信息都在当前字符串信息里, 且组合无穷!
```bash
#检测终端的颜色支持情况
curl -s https://raw.githubusercontent.com/JohnMorales/dotfiles/master/colors/24-bit-color.sh | bash

printf "\033[48;2;0;128;255mText on blue background\033[0m\n"
# ESC → 转义字符，八进制 \033，十六进制 0x1B。

# [ → 表示进入“控制序列引导”（CSI, Control Sequence Introducer）。

# 48(背景颜色设置的代号); 2(RGB 3*8 = 24位真彩色模式);;0(R);128(G);255(B);m(结束);

# m → 表示这是一个“选择图形再现 (SGR, Select Graphic Rendition)”命令，即控制样式/颜色。

# 0(重置);
```


说白了, 我们只需要做到刷新就好. 
但有一个问题, `colortest2`实验表明, 终端的渲染能力有限. 彩色背景+彩色文字, 很快就卡卡的. 但单独背景或文字, 可以霓虹灯一样跑一段时间. 是内存还是计算的原因? 是终端的能力不足还是我程序优化不好? 终端显示的理论上限在哪? 

